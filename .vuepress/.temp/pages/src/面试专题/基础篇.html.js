export const data = JSON.parse("{\"key\":\"v-0eac564c\",\"path\":\"/src/%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98/%E5%9F%BA%E7%A1%80%E7%AF%87.html\",\"title\":\"基础篇\",\"lang\":\"zh-CN\",\"frontmatter\":{\"category\":[\"面试\"],\"description\":\"基础篇 基础篇要点：算法、数据结构、基础设计模式 1. 二分查找 算法描述 前提：有已排序数组 A（假设已经做好） 定义左边界 L、右边界 R，确定搜索范围，循环执行二分查找（3、4两步） 获取中间索引 M = Floor((L+R) /2) 中间索引的值 A[M] 与待搜索的值 T 进行比较 ① A[M] == T 表示找到，返回中间索引 ② A[M] &gt; T，中间值右侧的其它元素都大于 T，无需比较，中间索引左边去找，M - 1 设置为右边界，重新查找 ③ A[M] &lt; T，中间值左侧的其它元素都小于 T，无需比较，中间索引右边去找， M + 1 设置为左边界，重新查找 当 L &gt; R 时，表示没有找到，应结束循环\",\"head\":[[\"meta\",{\"property\":\"og:url\",\"content\":\"https://github.com/Beisheng8888/blog/src/%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98/%E5%9F%BA%E7%A1%80%E7%AF%87.html\"}],[\"meta\",{\"property\":\"og:site_name\",\"content\":\"Mr.Jh\"}],[\"meta\",{\"property\":\"og:title\",\"content\":\"基础篇\"}],[\"meta\",{\"property\":\"og:description\",\"content\":\"基础篇 基础篇要点：算法、数据结构、基础设计模式 1. 二分查找 算法描述 前提：有已排序数组 A（假设已经做好） 定义左边界 L、右边界 R，确定搜索范围，循环执行二分查找（3、4两步） 获取中间索引 M = Floor((L+R) /2) 中间索引的值 A[M] 与待搜索的值 T 进行比较 ① A[M] == T 表示找到，返回中间索引 ② A[M] &gt; T，中间值右侧的其它元素都大于 T，无需比较，中间索引左边去找，M - 1 设置为右边界，重新查找 ③ A[M] &lt; T，中间值左侧的其它元素都小于 T，无需比较，中间索引右边去找， M + 1 设置为左边界，重新查找 当 L &gt; R 时，表示没有找到，应结束循环\"}],[\"meta\",{\"property\":\"og:type\",\"content\":\"article\"}],[\"meta\",{\"property\":\"og:locale\",\"content\":\"zh-CN\"}],[\"meta\",{\"property\":\"og:updated_time\",\"content\":\"2023-07-19T01:48:53.000Z\"}],[\"meta\",{\"property\":\"article:author\",\"content\":\"Mr.Jh\"}],[\"meta\",{\"property\":\"article:modified_time\",\"content\":\"2023-07-19T01:48:53.000Z\"}],[\"script\",{\"type\":\"application/ld+json\"},\"{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@type\\\":\\\"Article\\\",\\\"headline\\\":\\\"基础篇\\\",\\\"image\\\":[\\\"\\\"],\\\"dateModified\\\":\\\"2023-07-19T01:48:53.000Z\\\",\\\"author\\\":[{\\\"@type\\\":\\\"Person\\\",\\\"name\\\":\\\"Mr.Jh\\\",\\\"url\\\":\\\"https://github.com/Beisheng8888\\\"}]}\"]]},\"headers\":[{\"level\":2,\"title\":\"1. 二分查找\",\"slug\":\"_1-二分查找\",\"link\":\"#_1-二分查找\",\"children\":[]},{\"level\":2,\"title\":\"2. 冒泡排序\",\"slug\":\"_2-冒泡排序\",\"link\":\"#_2-冒泡排序\",\"children\":[]},{\"level\":2,\"title\":\"3. 选择排序\",\"slug\":\"_3-选择排序\",\"link\":\"#_3-选择排序\",\"children\":[]},{\"level\":2,\"title\":\"4. 插入排序\",\"slug\":\"_4-插入排序\",\"link\":\"#_4-插入排序\",\"children\":[]},{\"level\":2,\"title\":\"5. 希尔排序\",\"slug\":\"_5-希尔排序\",\"link\":\"#_5-希尔排序\",\"children\":[]},{\"level\":2,\"title\":\"6. 快速排序\",\"slug\":\"_6-快速排序\",\"link\":\"#_6-快速排序\",\"children\":[]},{\"level\":2,\"title\":\"7. ArrayList\",\"slug\":\"_7-arraylist\",\"link\":\"#_7-arraylist\",\"children\":[]},{\"level\":2,\"title\":\"8. Iterator\",\"slug\":\"_8-iterator\",\"link\":\"#_8-iterator\",\"children\":[]},{\"level\":2,\"title\":\"9. LinkedList\",\"slug\":\"_9-linkedlist\",\"link\":\"#_9-linkedlist\",\"children\":[]},{\"level\":2,\"title\":\"10. HashMap\",\"slug\":\"_10-hashmap\",\"link\":\"#_10-hashmap\",\"children\":[{\"level\":3,\"title\":\"1）基本数据结构\",\"slug\":\"_1-基本数据结构\",\"link\":\"#_1-基本数据结构\",\"children\":[]},{\"level\":3,\"title\":\"2）树化与退化\",\"slug\":\"_2-树化与退化\",\"link\":\"#_2-树化与退化\",\"children\":[]},{\"level\":3,\"title\":\"3）索引计算\",\"slug\":\"_3-索引计算\",\"link\":\"#_3-索引计算\",\"children\":[]},{\"level\":3,\"title\":\"4）put 与扩容\",\"slug\":\"_4-put-与扩容\",\"link\":\"#_4-put-与扩容\",\"children\":[]},{\"level\":3,\"title\":\"5）并发问题\",\"slug\":\"_5-并发问题\",\"link\":\"#_5-并发问题\",\"children\":[]},{\"level\":3,\"title\":\"6）key 的设计\",\"slug\":\"_6-key-的设计\",\"link\":\"#_6-key-的设计\",\"children\":[]}]},{\"level\":2,\"title\":\"11. 单例模式\",\"slug\":\"_11-单例模式\",\"link\":\"#_11-单例模式\",\"children\":[]}],\"git\":{\"createdTime\":1689574668000,\"updatedTime\":1689731333000,\"contributors\":[{\"name\":\"北省\",\"email\":\"jih6666@126.com\",\"commits\":3}]},\"readingTime\":{\"minutes\":17.03,\"words\":5109},\"filePathRelative\":\"src/面试专题/基础篇.md\",\"localizedDate\":\"2023年7月17日\",\"excerpt\":\"<h1> 基础篇</h1>\\n<blockquote>\\n<p><em><strong>基础篇要点：算法、数据结构、基础设计模式</strong></em></p>\\n</blockquote>\\n<h2> 1. 二分查找</h2>\\n<p><strong>算法描述</strong></p>\\n<ol>\\n<li>\\n<p>前提：有已排序数组 A（假设已经做好）</p>\\n</li>\\n<li>\\n<p>定义左边界 L、右边界 R，确定搜索范围，循环执行二分查找（3、4两步）</p>\\n</li>\\n<li>\\n<p>获取中间索引 M = Floor((L+R) /2)</p>\\n</li>\\n<li>\\n<p>中间索引的值  A[M] 与待搜索的值 T 进行比较</p>\\n<p>① A[M] == T 表示找到，返回中间索引</p>\\n<p>② A[M] &gt; T，中间值右侧的其它元素都大于 T，无需比较，中间索引左边去找，M - 1 设置为右边界，重新查找</p>\\n<p>③ A[M] &lt; T，中间值左侧的其它元素都小于 T，无需比较，中间索引右边去找， M + 1 设置为左边界，重新查找</p>\\n</li>\\n<li>\\n<p>当 L &gt; R 时，表示没有找到，应结束循环</p>\\n</li>\\n</ol>\",\"autoDesc\":true}")

export const data = JSON.parse("{\"key\":\"v-3a884f76\",\"path\":\"/src/JavaSE/%E5%A4%9A%E7%BA%BF%E7%A8%8B02.html\",\"title\":\"多线程02\",\"lang\":\"zh-CN\",\"frontmatter\":{\"description\":\"多线程02 1.线程池 1.1 线程状态介绍 当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。线程对象在不同的时期有不同的状态。那么Java中的线程存在哪几种状态呢？Java中的线程 状态被定义在了java.lang.Thread.State枚举类中，State枚举类的源码如下： public class Thread { public enum State { /* 新建 */ NEW , /* 可运行状态 */ RUNNABLE , /* 阻塞状态 */ BLOCKED , /* 无限等待状态 */ WAITING , /* 计时等待 */ TIMED_WAITING , /* 终止 */ TERMINATED; \\t} // 获取当前线程的状态 public State getState() { return jdk.internal.misc.VM.toThreadState(threadStatus); } }\",\"head\":[[\"meta\",{\"property\":\"og:url\",\"content\":\"https://github.com/Beisheng8888/blog/src/JavaSE/%E5%A4%9A%E7%BA%BF%E7%A8%8B02.html\"}],[\"meta\",{\"property\":\"og:site_name\",\"content\":\"冀辉的博客\"}],[\"meta\",{\"property\":\"og:title\",\"content\":\"多线程02\"}],[\"meta\",{\"property\":\"og:description\",\"content\":\"多线程02 1.线程池 1.1 线程状态介绍 当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。线程对象在不同的时期有不同的状态。那么Java中的线程存在哪几种状态呢？Java中的线程 状态被定义在了java.lang.Thread.State枚举类中，State枚举类的源码如下： public class Thread { public enum State { /* 新建 */ NEW , /* 可运行状态 */ RUNNABLE , /* 阻塞状态 */ BLOCKED , /* 无限等待状态 */ WAITING , /* 计时等待 */ TIMED_WAITING , /* 终止 */ TERMINATED; \\t} // 获取当前线程的状态 public State getState() { return jdk.internal.misc.VM.toThreadState(threadStatus); } }\"}],[\"meta\",{\"property\":\"og:type\",\"content\":\"article\"}],[\"meta\",{\"property\":\"og:locale\",\"content\":\"zh-CN\"}],[\"meta\",{\"property\":\"article:author\",\"content\":\"Mr.JH\"}],[\"script\",{\"type\":\"application/ld+json\"},\"{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@type\\\":\\\"Article\\\",\\\"headline\\\":\\\"多线程02\\\",\\\"image\\\":[\\\"\\\"],\\\"dateModified\\\":null,\\\"author\\\":[{\\\"@type\\\":\\\"Person\\\",\\\"name\\\":\\\"Mr.JH\\\",\\\"url\\\":\\\"https://github.com/Beisheng8888\\\"}]}\"]]},\"headers\":[{\"level\":2,\"title\":\"1.线程池\",\"slug\":\"_1-线程池\",\"link\":\"#_1-线程池\",\"children\":[{\"level\":3,\"title\":\"1.1 线程状态介绍\",\"slug\":\"_1-1-线程状态介绍\",\"link\":\"#_1-1-线程状态介绍\",\"children\":[]},{\"level\":3,\"title\":\"1.2 线程池-基本原理\",\"slug\":\"_1-2-线程池-基本原理\",\"link\":\"#_1-2-线程池-基本原理\",\"children\":[]},{\"level\":3,\"title\":\"1.3 线程池-Executors默认线程池\",\"slug\":\"_1-3-线程池-executors默认线程池\",\"link\":\"#_1-3-线程池-executors默认线程池\",\"children\":[]},{\"level\":3,\"title\":\"1.4 线程池-Executors创建指定上限的线程池\",\"slug\":\"_1-4-线程池-executors创建指定上限的线程池\",\"link\":\"#_1-4-线程池-executors创建指定上限的线程池\",\"children\":[]},{\"level\":3,\"title\":\"1.5 线程池-ThreadPoolExecutor\",\"slug\":\"_1-5-线程池-threadpoolexecutor\",\"link\":\"#_1-5-线程池-threadpoolexecutor\",\"children\":[]},{\"level\":3,\"title\":\"1.6 线程池-参数详解\",\"slug\":\"_1-6-线程池-参数详解\",\"link\":\"#_1-6-线程池-参数详解\",\"children\":[]},{\"level\":3,\"title\":\"1.7 线程池-非默认任务拒绝策略\",\"slug\":\"_1-7-线程池-非默认任务拒绝策略\",\"link\":\"#_1-7-线程池-非默认任务拒绝策略\",\"children\":[]}]},{\"level\":2,\"title\":\"2. 原子性\",\"slug\":\"_2-原子性\",\"link\":\"#_2-原子性\",\"children\":[{\"level\":3,\"title\":\"2.1 volatile-问题\",\"slug\":\"_2-1-volatile-问题\",\"link\":\"#_2-1-volatile-问题\",\"children\":[]},{\"level\":3,\"title\":\"2.2 volatile解决\",\"slug\":\"_2-2-volatile解决\",\"link\":\"#_2-2-volatile解决\",\"children\":[]},{\"level\":3,\"title\":\"2.3 synchronized解决\",\"slug\":\"_2-3-synchronized解决\",\"link\":\"#_2-3-synchronized解决\",\"children\":[]},{\"level\":3,\"title\":\"2.4 原子性\",\"slug\":\"_2-4-原子性\",\"link\":\"#_2-4-原子性\",\"children\":[]},{\"level\":3,\"title\":\"2.5 volatile关键字不能保证原子性\",\"slug\":\"_2-5-volatile关键字不能保证原子性\",\"link\":\"#_2-5-volatile关键字不能保证原子性\",\"children\":[]},{\"level\":3,\"title\":\"2.6 原子性_AtomicInteger\",\"slug\":\"_2-6-原子性-atomicinteger\",\"link\":\"#_2-6-原子性-atomicinteger\",\"children\":[]},{\"level\":3,\"title\":\"2.7 AtomicInteger-内存解析\",\"slug\":\"_2-7-atomicinteger-内存解析\",\"link\":\"#_2-7-atomicinteger-内存解析\",\"children\":[]},{\"level\":3,\"title\":\"2.8 AtomicInteger-源码解析\",\"slug\":\"_2-8-atomicinteger-源码解析\",\"link\":\"#_2-8-atomicinteger-源码解析\",\"children\":[]},{\"level\":3,\"title\":\"2.9 悲观锁和乐观锁\",\"slug\":\"_2-9-悲观锁和乐观锁\",\"link\":\"#_2-9-悲观锁和乐观锁\",\"children\":[]}]},{\"level\":2,\"title\":\"3. 并发工具类\",\"slug\":\"_3-并发工具类\",\"link\":\"#_3-并发工具类\",\"children\":[{\"level\":3,\"title\":\"3.1 并发工具类-Hashtable\",\"slug\":\"_3-1-并发工具类-hashtable\",\"link\":\"#_3-1-并发工具类-hashtable\",\"children\":[]},{\"level\":3,\"title\":\"3.2 并发工具类-ConcurrentHashMap基本使用\",\"slug\":\"_3-2-并发工具类-concurrenthashmap基本使用\",\"link\":\"#_3-2-并发工具类-concurrenthashmap基本使用\",\"children\":[]},{\"level\":3,\"title\":\"3.3 并发工具类-ConcurrentHashMap1.7原理\",\"slug\":\"_3-3-并发工具类-concurrenthashmap1-7原理\",\"link\":\"#_3-3-并发工具类-concurrenthashmap1-7原理\",\"children\":[]},{\"level\":3,\"title\":\"3.4 并发工具类-ConcurrentHashMap1.8原理\",\"slug\":\"_3-4-并发工具类-concurrenthashmap1-8原理\",\"link\":\"#_3-4-并发工具类-concurrenthashmap1-8原理\",\"children\":[]},{\"level\":3,\"title\":\"3.5 并发工具类-CountDownLatch\",\"slug\":\"_3-5-并发工具类-countdownlatch\",\"link\":\"#_3-5-并发工具类-countdownlatch\",\"children\":[]},{\"level\":3,\"title\":\"3.6 并发工具类-Semaphore\",\"slug\":\"_3-6-并发工具类-semaphore\",\"link\":\"#_3-6-并发工具类-semaphore\",\"children\":[]}]}],\"readingTime\":{\"minutes\":21.62,\"words\":6486},\"filePathRelative\":\"src/JavaSE/多线程02.md\",\"excerpt\":\"<h1> 多线程02</h1>\\n<h2> 1.线程池</h2>\\n<h3> 1.1 线程状态介绍</h3>\\n<p>当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。线程对象在不同的时期有不同的状态。那么Java中的线程存在哪几种状态呢？Java中的线程</p>\\n<p>状态被定义在了java.lang.Thread.State枚举类中，State枚举类的源码如下：</p>\\n<div class=\\\"language-java line-numbers-mode\\\" data-ext=\\\"java\\\"><pre class=\\\"language-java\\\"><code><span class=\\\"token keyword\\\">public</span> <span class=\\\"token keyword\\\">class</span> <span class=\\\"token class-name\\\">Thread</span> <span class=\\\"token punctuation\\\">{</span>\\n\\n    <span class=\\\"token keyword\\\">public</span> <span class=\\\"token keyword\\\">enum</span> <span class=\\\"token class-name\\\">State</span> <span class=\\\"token punctuation\\\">{</span>\\n\\n        <span class=\\\"token comment\\\">/* 新建 */</span>\\n        <span class=\\\"token constant\\\">NEW</span> <span class=\\\"token punctuation\\\">,</span>\\n\\n        <span class=\\\"token comment\\\">/* 可运行状态 */</span>\\n        <span class=\\\"token constant\\\">RUNNABLE</span> <span class=\\\"token punctuation\\\">,</span>\\n\\n        <span class=\\\"token comment\\\">/* 阻塞状态 */</span>\\n        <span class=\\\"token constant\\\">BLOCKED</span> <span class=\\\"token punctuation\\\">,</span>\\n\\n        <span class=\\\"token comment\\\">/* 无限等待状态 */</span>\\n        <span class=\\\"token constant\\\">WAITING</span> <span class=\\\"token punctuation\\\">,</span>\\n\\n        <span class=\\\"token comment\\\">/* 计时等待 */</span>\\n        <span class=\\\"token constant\\\">TIMED_WAITING</span> <span class=\\\"token punctuation\\\">,</span>\\n\\n        <span class=\\\"token comment\\\">/* 终止 */</span>\\n        <span class=\\\"token constant\\\">TERMINATED</span><span class=\\\"token punctuation\\\">;</span>\\n\\n\\t<span class=\\\"token punctuation\\\">}</span>\\n\\n    <span class=\\\"token comment\\\">// 获取当前线程的状态</span>\\n    <span class=\\\"token keyword\\\">public</span> <span class=\\\"token class-name\\\">State</span> <span class=\\\"token function\\\">getState</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n        <span class=\\\"token keyword\\\">return</span> jdk<span class=\\\"token punctuation\\\">.</span>internal<span class=\\\"token punctuation\\\">.</span>misc<span class=\\\"token punctuation\\\">.</span><span class=\\\"token constant\\\">VM</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">toThreadState</span><span class=\\\"token punctuation\\\">(</span>threadStatus<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token punctuation\\\">}</span>\\n\\n<span class=\\\"token punctuation\\\">}</span>\\n</code></pre><div class=\\\"line-numbers\\\" aria-hidden=\\\"true\\\"><div class=\\\"line-number\\\"></div><div class=\\\"line-number\\\"></div><div class=\\\"line-number\\\"></div><div class=\\\"line-number\\\"></div><div class=\\\"line-number\\\"></div><div class=\\\"line-number\\\"></div><div class=\\\"line-number\\\"></div><div class=\\\"line-number\\\"></div><div class=\\\"line-number\\\"></div><div class=\\\"line-number\\\"></div><div class=\\\"line-number\\\"></div><div class=\\\"line-number\\\"></div><div class=\\\"line-number\\\"></div><div class=\\\"line-number\\\"></div><div class=\\\"line-number\\\"></div><div class=\\\"line-number\\\"></div><div class=\\\"line-number\\\"></div><div class=\\\"line-number\\\"></div><div class=\\\"line-number\\\"></div><div class=\\\"line-number\\\"></div><div class=\\\"line-number\\\"></div><div class=\\\"line-number\\\"></div><div class=\\\"line-number\\\"></div><div class=\\\"line-number\\\"></div><div class=\\\"line-number\\\"></div><div class=\\\"line-number\\\"></div><div class=\\\"line-number\\\"></div><div class=\\\"line-number\\\"></div><div class=\\\"line-number\\\"></div><div class=\\\"line-number\\\"></div></div></div>\",\"autoDesc\":true}")

if (import.meta.webpackHot) {
  import.meta.webpackHot.accept()
  if (__VUE_HMR_RUNTIME__.updatePageData) {
    __VUE_HMR_RUNTIME__.updatePageData(data)
  }
}

if (import.meta.hot) {
  import.meta.hot.accept(({ data }) => {
    __VUE_HMR_RUNTIME__.updatePageData(data)
  })
}
